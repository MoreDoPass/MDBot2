# InlineHook в MDBot2

## Обзор

`InlineHook` представляет собой механизм для перехвата выполнения функций в целевом процессе (WoW) путем модификации их начальных инструкций. Это достигается заменой нескольких первых байт целевой функции на инструкцию безусловного перехода (`jmp`) на пользовательский код-обработчик (трамплин). После выполнения пользовательского кода управление может быть возвращено оригинальной функции.

Этот тип хука также известен как "трамплинный хук" (trampoline hook).

## Архитектура

### Базовый класс `Hook`

`InlineHook` является наследником абстрактного класса `Hook` (определенного в `src/core/HookManager/Hook/Hook.h`). Базовый класс `Hook` определяет общий интерфейс для всех типов хуков в проекте, включая как минимум следующие чисто виртуальные методы, которые должны быть реализованы наследниками:

* `bool install()`: Устанавливает хук.
* `bool uninstall()`: Снимает хук.
* `QString description() const`: Возвращает описание хука.

### Класс `InlineHook`

Определен в `src/core/HookManager/Hook/InlineHook/InlineHook.h` и `InlineHook.cpp`.

**Ключевые особенности:**

1. **Конструктор:**

    ```cpp
    InlineHook(uintptr_t address, uintptr_t trampolinePtr, MemoryManager* memoryManager);
    ```

    * `address`: Адрес функции в целевом процессе, которую необходимо перехватить.
    * `trampolinePtr`: Адрес, куда будет записан сгенерированный трамплин (пользовательский код-обработчик). Примечание: в `CharacterHook` этот параметр в конструкторе `InlineHook` передается как 0, так как память под трамплин, вероятно, выделяется внутри `InlineHook::install` или `generateTrampoline`.
    * `memoryManager`: Указатель на экземпляр `MemoryManager`, который используется для операций чтения и записи в память целевого процесса, а также для выделения памяти под трамплин.

2. **Механизм работы:**
    * **Сохранение оригинальных байт:** Перед установкой хука `InlineHook` считывает и сохраняет несколько первых байт целевой функции (`m_originalBytes`). Количество этих байт (`m_patchSize`) должно быть достаточным для размещения инструкции `jmp` (обычно 5 байт для 32-битного относительного `jmp`).
    * **Патчинг:** В начало целевой функции записывается инструкция `jmp`, перенаправляющая выполнение на адрес `m_trampolinePtr`.
    * **Трамплин (`generateTrampoline()`):** Это чисто виртуальный метод, который должен быть переопределен в каждом классе-наследнике `InlineHook`. Его задача — сгенерировать байт-код, который будет выполняться при срабатывании хука. Обычно трамплин выполняет следующие действия:
        1. Сохраняет нужные регистры.
        2. Выполняет пользовательскую логику (например, считывает данные, вызывает другие функции).
        3. Восстанавливает сохраненные оригинальные байты целевой функции (те, что были затерты `jmp`).
        4. Выполняет эти оригинальные байты.
        5. Передает управление обратно на адрес в оригинальной функции, следующий сразу за перезаписанными байтами.
        Или, как в случае `CharacterHook`, трамплин может сохранить необходимые данные (например, значение регистра `EAX`), затем выполнить оригинальные байты и осуществить переход обратно к основной логике целевой функции.
    * **Установка (`install()`):**
        1. Выделяет память для трамплина, если это необходимо (размер определяется наследником).
        2. Вызывает `generateTrampoline()` для генерации кода трамплина и записи его по адресу `m_trampolinePtr`.
        3. Сохраняет оригинальные байты целевой функции.
        4. Выполняет патчинг целевой функции (записывает `jmp` на `m_trampolinePtr`).
    * **Снятие (`uninstall()`):**
        1. Восстанавливает оригинальные байты в целевой функции, удаляя `jmp`.
        2. Освобождает память, выделенную под трамплин, если это необходимо.

### Пример использования: `CharacterHook`

`CharacterHook` (определен в `src/core/Bot/Character/CharacterHook.h`) является хорошим примером наследования от `InlineHook`. Он предназначен для перехвата указателя на структуру данных персонажа в игре.

**Реализация:**

1. **Наследование:** `class CharacterHook : public InlineHook`.
2. **Конструктор:**

    ```cpp
    CharacterHook(uintptr_t address, MemoryManager* memoryManager, uintptr_t savePtrAddress);
    ```

    * `savePtrAddress`: Адрес в памяти целевого процесса, куда `CharacterHook` будет сохранять перехваченный указатель (обычно значение регистра `EAX`).
3. **`generateTrampoline()`:**
    * Генерирует ассемблерный код, который:
        1. Сохраняет значение регистра `EAX` по адресу `m_savePtrAddress` (`mov [m_savePtrAddress], eax`).
        2. Вставляет оригинальные байты функции, которые были заменены `jmp` при установке хука.
        3. Выполняет `jmp` обратно на адрес в оригинальной функции, следующий сразу за этими оригинальными байтами, чтобы продолжить нормальное выполнение перехваченной функции.
    * Этот код записывается по адресу `m_trampolinePtr` (который был выделен `InlineHook`).

**Интеграция в `Character` (модуль бота):**

Класс `Character` (в `src/core/Bot/Character/Character.cpp`) использует `CharacterHook` следующим образом:

1. **Инициализация:**
    * В конструкторе `Character` с помощью `MemoryManager` выделяется небольшой участок памяти в целевом процессе (`m_savePtrAddress`).
    * Создается экземпляр `CharacterHook`, ему передается целевой адрес для хука, `MemoryManager` и `m_savePtrAddress`.
    * Вызывается метод `install()` у объекта `CharacterHook`.

    ```cpp
    // В конструкторе Character::Character(...)
    m_savePtrAddress = m_memoryManager->allocMemory(sizeof(uintptr_t));
    // ... проверка m_savePtrAddress ...
    m_hook = new CharacterHook(0x4FA64E, m_memoryManager, reinterpret_cast<uintptr_t>(m_savePtrAddress));
    if (!m_hook->install()) {
        // ... обработка ошибки ...
    }
    ```

2. **Получение данных:**
    * После установки хука, когда целевая функция в игре вызывается, `CharacterHook` сохраняет указатель на структуру персонажа (из `EAX`) по адресу `m_savePtrAddress`.
    * Класс `Character` в своем методе `updateFromMemory()` может затем прочитать этот указатель из `m_savePtrAddress` с помощью `MemoryManager::readMemory()`, чтобы получить доступ к данным персонажа.
3. **Деинициализация:**
    * В деструкторе `Character` вызывается `m_hook->uninstall()` для снятия хука и восстановления оригинальных байт целевой функции.
    * Экземпляр `CharacterHook` удаляется.
    * Память, выделенная под `m_savePtrAddress`, освобождается с помощью `MemoryManager::freeMemory()`.

Этот пример демонстрирует полный цикл работы `InlineHook`: создание специализированного хука-наследника, его установка, перехват данных и корректное удаление.
