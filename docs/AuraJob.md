Итоги реверс-инжиниринга структуры аур в WoW 3.3.5a
1. Изначальная задача
Нашей целью было полностью расшифровать, как клиент игры хранит информацию об аурах (баффах и дебаффах) для объекта Unit. Это было необходимо для создания в боте логики, способной проверять наличие аур у персонажа, цели и других юнитов для принятия решений в Дереве Поведения.
2. Путь исследования: от хаоса к порядку
Наш путь был классическим примером реверс-инжиниринга:
Начальная точка: Мы начали с трех загадочных адресов в Cheat Engine, которые менялись при наложении баффа. Это навело нас на мысль, что данные хранятся в нескольких связанных структурах.
Анализ кода (IDA Pro): Мы начали анализировать функции, которые обращались к этим адресам. Это позволило нам обнаружить две ключевые структуры (AuraSlot и AuraIndexEntry) и два разных массива (m_auras и m_visibleAuras).
Гипотезы и опровержения: Мы прошли через несколько теорий:
Теория о фильтрах: Пытались отсеять "мусор" по casterGuid или expireTime. Оказалось ненадёжно.
Теория о счетчике в AuraSlot: Мы детально реверснули все поля 24-байтной структуры и доказали, что счетчика внутри нее нет.
Финальный прорыв: Твои последние наблюдения за поведением полей 0xDD0 и 0xEE0 при переходе от 16 к 17 аурам стали ключом к разгадке. Мы доказали существование двух режимов работы и нашли точные поля, отвечающие за управление ими.
3. Ключевые открытия: Архитектура системы аур
Мы выяснили, что система аур в WoW 3.3.5a — это умный, оптимизированный механизм, работающий в двух режимах.
Режим 1: "Простой" (≤ 16 аур)
Хранилище: Используется встроенный массив AuraSlot m_auras[16] по смещению 0xC50 прямо внутри структуры Unit.
Счетчик: Роль счетчика выполняет поле m_auraCount_or_Flag по смещению 0xDD0. Оно содержит точное количество активных аур (например, 13).
Режим 2: "Сложный" (> 16 аур)
Триггер: Переход в этот режим происходит, как только количество аур становится 17.
Хранилище: Игра выделяет динамический массив AuraSlot в другом месте памяти ("куче"). Указатель на этот массив записывается в поле по смещению 0xC58 (которое в "простом" режиме является частью встроенного массива).
Управление:
Поле m_auraCount_or_Flag (0xDD0) меняет свою роль и становится флагом, принимая значение -1.
Поле m_auras_capacity по смещению 0xEE0 "активируется" и начинает хранить вместимость (capacity) выделенного динамического массива (например, 28).
4. Финальные структуры данных (для Unit.h в DLL)
Мы создали финальную, точную и прагматичную структуру, которая содержит только необходимые для работы поля на их доказанных смещениях.

```
#pragma once
#include "WorldObject.h"
// ... другие инклюды ...

#pragma pack(push, 1)

// Вспомогательные структуры
struct CMovement { /* ... */ };

struct AuraSlot
{
    uint32_t casterGuid_low;
    uint32_t casterGuid_high;
    int32_t  spellId;
    uint32_t AuraFlags;
    int32_t  duration;
    uint32_t expireTime;
};

// Финальная, объединенная структура Unit
struct Unit : public WorldObject
{
    char       _pad0[0x8];                      // Смещение 0xD0
    CMovement* pMovement;                       // Смещение 0xD8
    char       _pad1[0x6AC];                    // Смещение 0xDC
    CMovement  m_movement;                      // Смещение 0x788
    char       _pad2[0x3F8];                    // Смещение 0x858
    AuraSlot   m_auras[16];                     // Смещение 0xC50 (используется и как массив, и для указателя на 0xC58)
    int32_t    m_auraCount_or_Flag;             // Смещение 0xDD0
    char       _pad3[0x10C];                    // Смещение 0xDD4
    int32_t    m_auras_capacity;                // Смещение 0xEE0
    char       _pad4[0xAD4];                    // Смещение 0xEE4
    uint32_t   health;                          // Смещение 0x19B8
    uint32_t   mana;                            // Смещение 0x19BC
    char       _pad5[0x18];                     // Смещение 0x19C0
    uint32_t   maxHealth;                       // Смещение 0x19D8
    uint32_t   maxMana;                         // Смещение 0x19DC
    char       _pad6[0x50];                     // Смещение 0x19E0
    uint32_t   level;                           // Смещение 0x1A30
};

#pragma pack(pop)
```

5. Финальный алгоритм (функция ReadUnitAuras в DLL)
Мы разработали финальный, надежный алгоритм, который точно читает ауры в обоих режимах, не захватывая "мусор".

```
void ReadUnitAuras(Unit* pUnit, GameObjectInfo& outInfo)
{
    outInfo.auraCount = 0;
    if (!pUnit) return;

    AuraSlot* auraArray = nullptr;
    int aurasToScan = 0;

    // Шаг 1: Проверяем режим работы и получаем правильные данные
    if (pUnit->m_auraCount_or_Flag != -1)
    {
        // РЕЖИМ 1: "Простой"
        auraArray = pUnit->m_auras;
        aurasToScan = pUnit->m_auraCount_or_Flag;
    }
    else
    {
        // РЕЖИМ 2: "Сложный"
        auraArray = *(AuraSlot**)((char*)pUnit + 0xC58);
        aurasToScan = pUnit->m_auras_capacity;
    }

    if (!auraArray) return;

    // Шаг 2: В цикле с ТОЧНОЙ границей читаем ID спеллов
    for (int i = 0; i < aurasToScan; ++i)
    {
        if (outInfo.auraCount >= MAX_AURAS_PER_UNIT) break;
        
        try
        {
            if (auraArray[i].spellId != 0)
            {
                outInfo.auras[outInfo.auraCount] = auraArray[i].spellId;
                outInfo.auraCount++;
            }
        }
        catch (...) { break; }
    }
}
```
