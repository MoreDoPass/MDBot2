[ ] Ша-г 2: Проектирование "Пульта Управления" (RecastBuilder.h)
    [x] Описан публичный контракт в RecastBuilder.h
    [x] Создан скелет реализации в RecastBuilder.cpp

[ ] Шаг 3: Реализация "Внутренней Кухни" (RecastBuilder.cpp)
Здесь мы пишем всю основную логику, пряча ее от остального мира. Весь процесс будет внутри метода build.
Подготовка:
Проверяем, что нам вообще дали геометрию. Если векторы пустые — сразу возвращаем ошибку.
Ключевой момент: Конвертируем оси! Создаем временный массив вершин и меняем каждую вершину из (x, y, z) в (x, z, -y), как мы и обсуждали.
Вычисляем габариты всей геометрии (Bounding Box) и дозаполняем наш "чертеж" rcConfig.
Волшебство Recast (Вокселизация):
Это последовательный вызов функций Recast, которые превращают треугольники в "воксели" (3D-пиксели).
rcCreateHeightfield, rcRasterizeTriangles, rcFilterWalkableSurfaces и т.д.
Волшебство Recast (Полигонизация):
Другая последовательность вызовов, которая превращает воксели в красивые навигационные полигоны.
rcBuildCompactHeightfield, rcBuildContours, rcBuildPolyMesh, и т.д.
Финальный Аккорд (Detour):
Берем готовые полигоны из шага 3.
Вызываем dtCreateNavMeshData, которая упаковывает все это в единый, готовый к сохранению байтовый массив.
Возвращаем этот массив в виде std::vector<unsigned char>.

[ ] Шаг 4: Интеграция с "Прорабом" (NavMeshGenerator)
Теперь наш главный класс NavMeshGenerator становится намного проще и чище. Он будет управлять процессом генерации для каждого ADT файла.

В NavMeshGenerator.h:
[ ] Добавляем приватное поле — указатель на нашего строителя (RecastBuilder).
[ ] Добавляем публичный метод, например, `buildadt(const std::string& adtFilePath, const std::string& outputPath)`. Этот метод будет отвечать за загрузку ADT, обработку его геометрии и создание navmesh.

В NavMeshGenerator.cpp:
Внутри `buildAdt`:
[ ] Загружаем ADT файл.
[ ] Извлекаем геометрию (вершины и треугольники) для этого ADT.
[ ] Создаем и настраиваем "чертеж" rcConfig.
[ ] Создаем наш RecastBuilder, передав ему этот чертеж.
[ ] Вызываем `builder->build(adtVertices, adtTriangleIndices)`.
[ ] Если результат не пустой, берем полученный вектор байт и записываем его в файл outputPath. Имя файла должно соответствовать ADT, например, `Azeroth_32_48.nav`.
[ ] Реализовать итерацию по всем ADT карты и вызов для них `buildAdt`.