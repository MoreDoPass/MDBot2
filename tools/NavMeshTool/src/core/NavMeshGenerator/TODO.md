[x] Ша-г 2: Проектирование "Пульта Управления" (RecastBuilder.h)
    [x] Описан публичный контракт в RecastBuilder.h
    [x] Создан скелет реализации в RecastBuilder.cpp

[x] Шаг 3: Реализация "Внутренней Кухни" (RecastBuilder.cpp)
Здесь мы пишем всю основную логику, пряча ее от остального мира. Весь процесс будет внутри метода build.
Подготовка:
Проверяем, что нам вообще дали геометрию. Если векторы пустые — сразу возвращаем ошибку.
Ключевой момент: Конвертируем оси! Создаем временный массив вершин и меняем каждую вершину из (x, y, z) в (x, z, -y), как мы и обсуждали.
Вычисляем габариты всей геометрии (Bounding Box) и дозаполняем наш "чертеж" rcConfig.
Волшебство Recast (Вокселизация):
Это последовательный вызов функций Recast, которые превращают треугольники в "воксели" (3D-пиксели).
rcCreateHeightfield, rcRasterizeTriangles, rcFilterWalkableSurfaces и т.д.
Волшебство Recast (Полигонизация):
Другая последовательность вызовов, которая превращает воксели в красивые навигационные полигоны.
rcBuildCompactHeightfield, rcBuildContours, rcBuildPolyMesh, и т.д.
Финальный Аккорд (Detour):
Берем готовые полигоны из шага 3.
Вызываем dtCreateNavMeshData, которая упаковывает все это в единый, готовый к сохранению байтовый массив.
Возвращаем этот массив в виде std::vector<unsigned char>.
Шаг 4: Интеграция с "Прорабом" (NavMeshGenerator)
Теперь наш главный класс NavMeshGenerator становится намного проще и чище.
В NavMeshGenerator.h: Добавляем приватное поле — указатель на нашего строителя (RecastBuilder).
В NavMeshGenerator.cpp:
Создаем новый публичный метод buildNavMesh(const std::string& outputPath).
Внутри него:
Создаем и настраиваем тот самый "чертеж" rcConfig.
Создаем наш RecastBuilder, передав ему этот чертеж.
Вызываем builder->build(m_worldVertices, m_worldTriangleIndices).
Если результат не пустой, то просто берем полученный вектор байт и записываем его в файл outputPath.