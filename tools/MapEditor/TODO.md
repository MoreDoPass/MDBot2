# План перехода на Вокселизацию + A* на вокселях

## Фаза 1: Основная структура Воксельного Мира и его "Изучение"

1. **Определить структуру данных для Воксельного Мира:**
    * [ ] Создать класс `VoxelWorld` или `VoxelMap`.
    * [ ] Определить и реализовать механизм задания размера вокселя (например, 0.5м x 0.5м x 0.5м).
    * [ ] Определить механизм задания границ мира для `MapEditor` (для бота - область вокруг игрока).
    * [ ] Реализовать хранение вокселей (начать с простого 3D-массива, в перспективе - октодерево или spatial hash grid).
    * [ ] Определить и реализовать перечисление `VoxelState` (UNKNOWN, FREE_GROUND, FREE_AIR, FREE_WATER, OBSTACLE и т.д.).

2. **Механизм "Изучения" (Заполнения) Воксельной Карты:**
    * **Для `MapEditor` и Бота:**
        * [ ] Реализовать заполнение на основе Raycasting (используя существующий `Core::LoS`):
            * Пометка вокселей вдоль луча до столкновения как `FREE_AIR` / `FREE_WATER`.
            * Пометка вокселя в точке столкновения (и вокруг) как `OBSTACLE`.
            * Пометка `FREE_GROUND` с помощью лучей вниз от позиции игрока/камеры.
    * **Для Бота (в перспективе):**
        * [ ] Реализовать заполнение на основе столкновений игрока с геометрией мира.
        * [ ] Пометка проходимых вокселей при успешном движении.
    * **Для `MapEditor`:**
        * [ ] Реализовать ручные инструменты ("кисть") для пометки областей вокселей.
        * [ ] Реализовать "окрашивание" вокселей вдоль пути игрока при записи маршрута.
        * [ ] Реализовать сохранение/загрузку состояния воксельной карты.

3. **Визуализация Вокселей в `Map3DView`:**
    * [ ] Реализовать базовую (отладочную) отрисовку небольшого участка вокселей.
    * [ ] Передать в `Map3DView` методы для загрузки и отображения данных из `VoxelWorld`.
    * [ ] (Опционально/В перспективе) Оптимизировать визуализацию (рисовать только поверхностные воксели, greedy meshing).

## Фаза 2: Реализация A* на Воксельной Сетке

1. **Адаптация/Создание A* для Вокселей:**
    * [ ] Создать новую версию A* или модифицировать существующий `AStar.cpp` для работы с `VoxelWorld`.
        * Узел графа - воксель (координаты/индекс).
        * Определение соседей для вокселя (6 или 26).
        * Проверка проходимости ребра между вокселями на основе их `VoxelState`.
        * Реализация расчета стоимости перехода (gScore), возможно, с учетом типа вокселя/действия (взлет).
        * Реализация эвристики (hScore) - Евклидово/Манхэттенское расстояние.
        * Результат поиска - список координат/индексов вокселей.

2. **Интеграция A* с `VoxelWorld`:**
    * [ ] Создать функцию типа `findPathAStar_Voxel(const VoxelWorld& voxelMap, VoxelCoord startVoxel, VoxelCoord goalVoxel, MovementType type)`.
    * [ ] Реализовать поддержку `MovementType` (WALK, FLY, SWIM) для учета разных типов проходимых вокселей.

3. **Сглаживание Пути (Post-Processing):**
    * [ ] Реализовать простой алгоритм сглаживания пути (проверка прямой видимости между точками пути и удаление промежуточных).
    * [ ] (Опционально/В перспективе) Изучить и реализовать более сложные алгоритмы сглаживания.

## Фаза 3: Использование в `MapEditor` и для Бота

1. **`MapEditor`:**
    * [ ] Интегрировать инструменты для "ощупывания" и редактирования вокселей в UI.
    * [ ] Добавить функционал запуска A* между двумя выбранными точками (вокселями) и отображения пути.
    * [ ] Реализовать визуализацию проходимых/непроходимых зон на основе воксельной карты.
    * [ ] Расширить `MapDataManager.cpp` и `MapData.h` для сохранения/загрузки воксельных данных.

2. **Бот (в перспективе):**
    * [ ] Реализовать динамическое построение/обновление воксельной карты вокруг бота.
    * [ ] Реализовать логику запроса пути A* на вокселях при постановке навигационной задачи.
    * [ ] Интегрировать сглаживание пути.
    * [ ] Реализовать движение по сглаженному воксельному пути.
    * [ ] Использовать `BugPathfinder` для локального обхода динамических препятствий с последующим обновлением воксельной карты и перепланированием A*.

## Отложенные/Опциональные задачи

* [ ] Оптимизация хранения вокселей (октодеревья, spatial hash grid) - если простой массив будет неэффективен.
* [ ] Продвинутая визуализация всех вокселей в `MapEditor`.
* [ ] Генерация NavMesh из вокселей (значительно более сложный этап).
* [ ] Реализация RRT/RRT\* с использованием воксельной карты для проверки столкновений.

## Существующий код, который будет затронут/использован

* `MapData.h` / `MapDataManager.cpp`: Добавление поддержки воксельных данных.
* `AStar.cpp`: Модификация или создание новой версии для вокселей.
* `Map3DView.h/cpp`: Отображение вокселей и воксельных путей.
* `MainWindow.h/cpp`: Новый UI и логика для вокселизации.
* `LineOfSight.cpp`: Функции проверки пересечения для "ощупывания" мира.
