# Модуль Камеры (MapEditor)

## Обзор

Этот модуль содержит класс `Camera`, отвечающий за управление камерой в 3D-сцене редактора карт (`MapEditor`). Он инкапсулирует логику, связанную с положением, ориентацией, полем зрения (FOV) камеры, а также обработку пользовательского ввода для навигации.

## Назначение

Основная задача класса `Camera` — предоставить удобный интерфейс для:

* **Позиционирования и ориентации:** Управление положением камеры в пространстве (координаты X, Y, Z) и её направлением (рыскание, тангаж).
* **Генерации матрицы вида (View Matrix):** Расчет матрицы вида, необходимой для рендеринга 3D-сцены с точки зрения камеры.
* **Управления полем зрения (FOV):** Изменение угла обзора камеры, что влияет на перспективу.
* **Обработки ввода:** Преобразование команд от клавиатуры (движение вперед, назад, влево, вправо, вверх, вниз) и мыши (вращение, изменение FOV через колесо) в соответствующие изменения параметров камеры.

## Основные возможности

* **Конструктор:** Позволяет инициализировать камеру с начальной позицией, направлением "вверх" для мира, углами рыскания и тангажа.
* `getViewMatrix() const`: Возвращает матрицу вида (`QMatrix4x4`), рассчитанную на основе текущего положения и ориентации камеры. Эта матрица используется в шейдерах для преобразования вершин из мировых координат в координаты вида.
* `getFov() const`: Возвращает текущий угол обзора (FOV) в градусах. Используется для построения матрицы проекции.
* `getPosition() const`: Возвращает текущее положение камеры (`QVector3D`).
* `getYaw() const`, `getPitch() const`: Возвращают текущие углы рыскания и тангажа.
* `processKeyboard(const QSet<int>& pressedKeys, float deltaTime)`: Обновляет положение камеры на основе нажатых клавиш (используя перечисление `MovementDirection`, которое должно быть сопоставлено с фактическими кодами клавиш в `Map3DView`). `deltaTime` обеспечивает плавность движения независимо от частоты кадров.
* `processMouseMovement(float xoffset, float yoffset, bool constrainPitch = true)`: Обновляет ориентацию камеры (рыскание и тангаж) на основе смещения мыши. Параметр `constrainPitch` предотвращает "кувырок" камеры.
* `processMouseScroll(float yoffset)`: Обновляет FOV камеры на основе прокрутки колеса мыши.
* Внутренний метод `updateCameraVectors()`: Пересчитывает векторы `m_front`, `m_right` и `m_up` на основе углов рыскания и тангажа.

## Использование

Класс `Camera` предназначен для использования в качестве члена класса `Map3DView` (или любого другого класса, отвечающего за 3D-визуализацию).

1. **Инициализация:**
    Объект `Camera` создается в конструкторе `Map3DView`.

    ```cpp
    // В Map3DView.h
    #include "Camera/Camera.h"
    // ...
    private:
        Camera m_camera;

    // В Map3DView.cpp (конструктор)
    Map3DView::Map3DView(QWidget *parent)
        : QOpenGLWidget(parent),
          m_camera(QVector3D(0.0f, 10.0f, 20.0f), QVector3D(0.0f, 1.0f, 0.0f), -90.0f, -20.0f) 
          // Примерные начальные значения: позиция, мировой "вверх", рыскание, тангаж
    {
        // ...
    }
    ```

2. **Обработка ввода:**
    `Map3DView` перехватывает события клавиатуры и мыши и передает их соответствующим методам `m_camera`:

    ```cpp
    // В Map3DView.cpp
    void Map3DView::keyPressEvent(QKeyEvent *event) {
        // Логика добавления event->key() в m_pressedKeys
        // ...
    }

    // В слоте таймера (например, updateScene), который вызывается регулярно:
    void Map3DView::updateScene() {
        float deltaTime = // рассчитать время с прошлого кадра
        m_camera.processKeyboard(m_pressedKeys, deltaTime);
        update(); // Перерисовать виджет
    }

    void Map3DView::mouseMoveEvent(QMouseEvent *event) {
        float xoffset = event->pos().x() - m_lastMouseX;
        float yoffset = m_lastMouseY - event->pos().y(); // Инвертировано, т.к. Y-координаты обычно идут сверху вниз
        m_lastMouseX = event->pos().x();
        m_lastMouseY = event->pos().y();
        m_camera.processMouseMovement(xoffset, yoffset);
        update();
    }

    void Map3DView::wheelEvent(QWheelEvent *event) {
        m_camera.processMouseScroll(event->angleDelta().y() / 120.0f); // Деление для стандартизации значения прокрутки
        update();
    }
    ```

3. **Рендеринг:**
    В методе `paintGL()` класса `Map3DView` матрица вида и FOV получаются от объекта `m_camera` для настройки матриц проекции и вида перед отрисовкой объектов сцены:

    ```cpp
    // В Map3DView.cpp
    void Map3DView::paintGL() {
        // ...
        QMatrix4x4 view = m_camera.getViewMatrix();
        QMatrix4x4 projection;
        projection.perspective(m_camera.getFov(), m_aspectRatio, m_nearPlane, m_farPlane);
        
        // ... использовать view и projection в шейдерах ...
    }
    ```

## Зависимости

* Qt (для `QVector3D`, `QMatrix4x4`, `QSet`).

## Дальнейшее развитие

* Реализация различных режимов камеры (например, от первого лица, от третьего лица, свободный полет).
* Добавление методов для более сложного управления, таких как следование за объектом.
* Более продвинутые настройки чувствительности и скорости.
