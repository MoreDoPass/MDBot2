#pragma once
#include <cstdint>

#pragma pack(push, 1)

/**
 * @brief ИСТОРИЯ ДЕБАГА И РЕШЕНИЕ ПРОБЛЕМЫ ЧТЕНИЯ КУЛДАУНОВ (Постмортем)
 * @version 2.0
 * @date 20.09.2025
 *
 * @section problem Первоначальная проблема
 *
 * Изначальная реализация функции чтения кулдаунов (`ReadPlayerCooldowns`) была нестабильной
 * и приводила к частым падениям приложения с ошибкой нарушения доступа (Access Violation).
 * Сбой происходил внутри цикла обхода связанного списка, конкретно при попытке
 * разыменования указателя на узел для чтения поля `pNext` (ассемблерная инструкция `mov edx,[ecx+04]`).
 *
 * @section hypothesis1 Первая гипотеза и попытка решения: Состояние гонки
 *
 * Нашей первой теорией было классическое состояние гонки (Race Condition). Мы предположили,
 * что игровой клиент удаляет узел из списка в тот момент, когда наш DLL пытается его прочитать.
 * Это приводит к появлению "висячего указателя" (`dangling pointer`), обращение к которому
 * вызывает сбой.
 *
 * **Решение 1:** Для защиты от сбоев мы обернули код чтения памяти в блок
 * структурированной обработки исключений (`__try`/`__except`).
 *
 * **Результат:** Это сработало! Программа перестала падать. Однако это вскрыло более
 * глубокую, логическую проблему: отладочный лог начал заполняться непрерывными
 * сообщениями о перехваченных исключениях. Это означало, что `__try`/`__except`
 * просто маскировал симптом, но не лечил основную болезнь. Данные по кулдаунам
 * либо не читались совсем, либо читался только один элемент.
 *
 * @section diagnosis Вторая гипотеза и диагностика: Неверная логика обхода
 *
 * Так как падения прекратились, но данные были неверными, стало очевидно, что проблема
 * не только в гонке потоков, но и в самой логике обхода списка.
 *
 * **Решение 2 (Диагностика):** Мы внедрили в функцию подробное пошаговое логирование,
 * которое выводило в DbgView адрес каждого текущего узла (`pCurrent`), адрес
 * следующего/предыдущего узла (`pNext`/`pPrev`) и ID прочитанного заклинания.
 *
 * **Результат (Ключевое открытие):** Логи кристально ясно показали нашу ошибку. Мы пытались
 * обходить список ВПЕРЕД (через `pNext`), начиная с адреса из `0x00D3F5B0`. Однако
 * логи показали, что `pNext` первого же узла сразу указывал на "дозорный" узел конца
 * списка (`0x00D3F5B1`). Цикл немедленно завершался, прочитав только один, самый новый кулдаун.
 *
 * @section solution Финальное понимание и правильное решение
 *
 * Благодаря вашему анализу и логам мы восстановили правильную структуру работы списка:
 *
 * 1.  **`0x00D3F5B0`**: Это не начало списка, а указатель на **ГОЛОВУ** списка, которая
 *     является **САМЫМ НОВЫМ** добавленным кулдауном.
 * 2.  **`0x00D3F5B4`**: Это указатель на **ХВОСТ** списка, то есть на **САМЫЙ СТАРЫЙ** кулдаун.
 * 3.  **Правильный обход**: Чтобы прочитать ВСЕ кулдауны, начиная с самого нового,
 *     нужно было стартовать с узла по адресу из `0x00D3F5B0` и двигаться **НАЗАД** по списку,
 *     используя указатель `pPrev` (смещение `0x00` в структуре).
 * 4.  **Условие завершения**: Цикл обхода назад должен завершаться, когда указатель
 *     `pPrev` очередного узла указывает обратно на адрес глобального указателя `0x00D3F5B0`.
 *
 * **Финальная реализация:**
 *  - Стартуем с адреса, который лежит в `POINTER_TO_LAST_NODE` (`0x00D3F5B0`).
 *  - В цикле переходим к следующему узлу через `pCurrent = pCurrent->pPrev`.
 *  - Завершаем цикл, когда `pCurrent` становится равен `POINTER_TO_LAST_NODE`.
 *  - Сохраняем блок `__try`/`__except` как надежную страховку от реальных состояний гонки,
 *    которые все еще могут произойти, хоть и гораздо реже.
 *
 * @section takeaways Ключевые выводы
 *
 * - **SEH (`__try`/`__except`) — это щит, а не лекарство.** Он незаменим для предотвращения
 *   падений при работе с чужой памятью, но спам в логах — верный признак более глубокой логической ошибки.
 * - **Подробное логирование — лучший отладчик.** Когда поведение непонятно, логирование
 *   указателей и данных на каждом шаге цикла — самый быстрый способ найти ошибку в логике.
 * - **Никогда не доверяй предположениям о структуре данных.** Наше предположение об обходе
 *   через `pNext` было неверным. Всегда нужно верифицировать структуру через дампы памяти
 *   или инструменты вроде ReClass.
 */

/**
 * @struct CooldownInfoNode
 * @brief "Слепок" узла из глобального двусвязного списка кулдаунов персонажа.
 * @details Эта структура — результат реверс-инжиниринга. Список является динамическим,
 *          и единственный надежный способ проверить готовность способности — это
 *          пройти по списку и сравнить таймеры с текущим временем.
 */
struct CooldownInfoNode
{
    /**
     * @brief [0x00] Указатель на предыдущий элемент в двусвязном списке.
     * @details Используется для навигации по списку назад.
     *          Если `pPrev` указывает на "дозорный" узел (например, 0x00D3F5B0),
     *          значит, мы достигли конца списка при обратном обходе.
     */
    CooldownInfoNode* pPrev;

    /**
     * @brief [0x04] Указатель на следующий элемент в двусвязном списке.
     * @details Используется для навигации по списку вперед.
     *          Если `pNext` указывает на "дозорный" узел (например, 0x00D3F5B1),
     *          значит, мы достигли конца списка при прямом обходе.
     */
    CooldownInfoNode* pNext;

    /**
     * @brief [0x08] ID заклинания или эффекта предмета.
     */
    uint32_t spellId;

    /**
     * @brief [0x0C] ID предмета, если кулдаун был вызван его использованием.
     * @details Для обычных заклинаний это поле, как правило, равно 0.
     */
    uint32_t itemId;

    /**
     * @brief [0x10] Время начала кулдауна (в тиках, GetTickCount).
     * @details Используется как база для расчета оставшегося времени как для
     *          личного, так и для категорийного кулдауна.
     */
    uint32_t startTime;

    /**
     * @brief [0x14] Длительность "личного" кулдауна заклинания (в миллисекундах).
     * @details Например, для "Божественной бури" здесь будет ~7100.
     *          Это кулдаун, который принадлежит только этой конкретной способности.
     */
    uint32_t spellCooldown;

    /**
     * @brief [0x18] ID категории скиллов (триньки прожимные / инжерные динамиты /
     * Правосудия / Ранги одного скилла), к которой относится кулдаун.
     */
    uint32_t categoryId;

    /**
     * @brief [0x1C] Время начала кулдауна категории. (В тиках)
     * @details Может дублировать startTime или иметь собственное значение.
     */
    uint32_t categoryStartTime;

    /**
     * @brief [0x20] Длительность кулдауна категории (в миллисекундах).
     * @details Этот кулдаун накладывается на целую группу способностей.
     *          Например, для "Экзорцизма" здесь будет 15000, и это значение
     *          заблокирует все остальные ранги "Экзорцизма". Или "Правосудие"
     */
    uint32_t categoryCooldown;

    /**
     * @brief [0x24] Флаги или дополнительный идентификатор кулдауна.
     * @details Это поле используется внутренними функциями игры для дополнительной
     *          проверки при поиске кулдаунов, у которых нет личного `spellCooldown`.
     *          По результатам наблюдений, для стандартных боевых кулдаунов и ГКД
     *          это поле чаще всего равно 0.
     */
    uint32_t cooldownFlags;

    /**
     * @brief [0x28] Идентификатор типа Глобального Кулдауна (ГКД).
     * @details Ключевое поле для обнаружения ГКД. Это "метка" или "магическое число",
     *          которое указывает на тип глобального кулдауна.
     *          - Для стандартного боевого ГКД это значение равно 133.
     *          - Для ГКД от использования аур это значение может быть другим (например, 38).
     *          Для надежного определения боевого ГКД бот должен искать в списке узел,
     *          у которого это поле равно 133.
     */
    uint32_t TypeGlobalCooldown;

    /**
     * @brief [0x2C] Длительность Глобального Кулдауна (в миллисекундах).
     * @details Содержит фактическую длительность ГКД. Это значение не является
     *          статичным и зависит от характеристик персонажа (в первую очередь, от рейтинга скорости).
     *          Например, базовое значение 1500 мс может уменьшаться до ~1271 мс и ниже.
     *          Это поле имеет смысл только для узлов, где `TypeGlobalCooldown` указывает на то,
     *          что это узел ГКД.
     */
    uint32_t globalCooldown;
};

#pragma pack(pop)