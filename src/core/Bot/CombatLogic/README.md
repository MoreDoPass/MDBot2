```
5. Архитектура Боевой Логики: Модель "Мозг, Датчики, Мышцы"
Для реализации сложной и гибкой боевой логики, способной адаптироваться под любой класс, мы используем трехуровневую архитектуру, основанную на принципе разделения ответственности.
5.1. Уровень 1: "Мышцы" — Менеджеры (CombatManager, MovementManager)
Роль: "Тупые" исполнители.
Задача: Выполняют атомарные, низкоуровневые приказы. Они не содержат никакой логики принятия решений.
Пример: CombatManager::castSpell(spellId, guid) просто формирует команду и отправляет ее в DLL. Он не проверяет ни ГКД, ни кулдауны, ни расстояние.
5.2. Уровень 2: "Датчики" — Поставщики Данных и Узлы-Условия
Роль: Источники информации и простые "индикаторы".
Компоненты:
Поставщики Данных (Character, GameObjectManager): Кэшируют и предоставляют "сырые" данные о мире. Character хранит уникальные данные нашего персонажа (кулдауны, ГКД, комбо-поинты, текущая форма). GameObjectManager хранит данные обо всех видимых объектах (их ХП, позиция).
Узлы-Условия (IsSpellReadyCondition, IsInRangeCondition, IsTargetHealthCondition и т.д.): Маленькие, переиспользуемые "кирпичики" для Дерева Поведения. Каждый узел отвечает на один простой вопрос ("Готов ли спелл?", "Цель в радиусе 5м?", "У цели меньше 20% ХП?"), обращаясь к Поставщикам Данных.
5.3. Уровень 3: "Мозг" — Дерево Поведения и его Сборщики
Роль: Центр принятия всех стратегических и тактических решений.
Компоненты:
Узлы-Действия (CastSpellAction, MoveToTargetAction): Простые узлы, которые вызывают соответствующие методы у "Мышц" (Менеджеров).
Сборщики (RetributionBuilder, ArmsWarriorBuilder и т.д.): Это классы-"архитекторы", отвечающие за логику конкретного класса/специализации. Они строят сложное Дерево Поведения, комбинируя множество "Датчиков" (Условий) и "Мышц" (Действий) в нужной последовательности.
Пример ветки для заклинания "Казнь" (Воин):
Вся логика для этого действия собирается в ArmsWarriorBuilder из простых "кирпичиков":
code
Code
SequenceNode ("Попытаться казнить цель"):
|-- IsTargetHealthCondition(< 20%)  // Датчик: у цели меньше 20% ХП?
|-- IsSpellReadyCondition("Казнь")     // Датчик: "Казнь" готова (нет КД/ГКД)?
|-- HasResourceCondition(Ярость, 15)   // Датчик: хватает ли ярости?
|-- IsInRangeCondition(5м)            // Датчик: я в мили-радиусе?
'-- CastSpellAction("Казнь")         // Мышцы: отдать приказ на каст
Такой подход обеспечивает максимальную гибкость, переиспользуемость кода и прозрачность всей боевой логики.
```


```
Финальная Архитектура: Трехуровневая модель
Представьте себе пирамиду. На каждом уровне — своя степень "интеллекта" и ответственности.
Уровень 1: "Двигатель" (Менеджеры - CombatManager, MovementManager)
Это самый низкий и "тупой" уровень. Он ничего не решает. Он просто выполняет атомарные приказы.
CombatManager:
castSpell(spellId, guid): Единственная задача — сформировать команду и отправить ее в DLL. Никаких проверок.
MovementManager:
moveTo(position): Отправить команду на движение.
faceTarget(guid): Отправить команду на поворот.
Уровень 2: "Датчики и Проводка" (Состояния и Условия)
Это средний уровень. Он отвечает за получение информации о мире и предоставление ее в виде простых "да/нет" ответов.
Поставщики данных (Character, GameObjectManager):
Character: Хранит уникальные данные о нас (КД, ГКД, ярость, комбо-поинты, текущая форма/стойка/аура, наличие чарки на оружии).
GameObjectManager: Хранит данные обо всех видимых объектах (их ХП, баффы, позиция).
Узлы-Условия (Conditions): Это маленькие, переиспользуемые "лампочки-индикаторы" для Дерева Поведения. Каждый из них отвечает на один конкретный вопрос. И именно здесь мы реализуем все ваши найденные условия.
IsSpellReadyCondition(spellId): Лезет в Character, проверяет КД и ГКД.
HasResourceCondition(type, value): Лезет в Character, проверяет ману/ярость/энергию.
IsTargetHealthCondition(op, percent): Лезет в GOM, проверяет ХП цели (для экзекутов).
IsInMeleeRangeCondition(): Проверяет расстояние до цели.
IsFarEnoughCondition(distance): Проверяет, что мы дальше чем N метров (для рывков и стрельбы ханта).
IsFacingTargetCondition(): Проверяет поворот.
IsBehindTargetCondition(): Новый узел для разбойников.
HasComboPointsCondition(op, value): Новый узел для разбойников/фералов. Лезет в Character.
IsInFormCondition(form): Новый узел для друидов/варлоков. Лезет в Character.
IsStealthedCondition(bool): Новый узел для разбойников/фералов.
HasWeaponEnchantCondition(enchantId): Новый узел для шаманов.
IsCastingCondition(bool): Новый узел, который проверяет, не кастуем ли мы уже что-то.
Уровень 3: "Мозг" (Дерево Поведения и его Сборщики)
Это самый высокий уровень. Он ничего не знает о том, как работают проверки или действия. Он просто, как архитектор, берет готовые "кирпичики" (Условия и Действия) и строит из них логическую схему.
Узлы-Действия (CastSpellAction, MoveToTargetAction): Это "тупые" узлы, которые просто вызывают соответствующий метод у соответствующего Менеджера.
Сборщики (RetributionBuilder, ArmsWarriorBuilder, FeralDruidBuilder):
Вот где будет жить вся классовая логика!
ArmsWarriorBuilder возьмет кирпичики IsTargetHealthCondition(<, 20), IsSpellReadyCondition("Execute") и CastSpellAction("Execute") и сложит их в одну ветку.
FeralDruidBuilder возьмет IsInFormCondition("Cat"), HasComboPointsCondition(==, 5), IsBehindTargetCondition и CastSpellAction("Rip") и сложит их в другую ветку.
Почему эта модель решает все ваши проблемы?
Инкапсуляция:
Данные инкапсулированы в Character и GOM.
Проверки инкапсулированы в маленьких, независимых Узлах-Условиях.
Действия инкапсулированы в Менеджерах.
Логика класса инкапсулирована в своем Сборщике (Builder).
Масштабируемость и Переиспользуемость:
Вы пишете IsInRangeCondition один раз. И воин, и разбойник, и друид, и даже модуль сбора руды будут его использовать.
Хотите добавить новый класс, разбойника? Вы не трогаете CombatManager. Вы не трогаете CastSpellAction. Вы просто создаете новый файл SubtletyRogueBuilder.cpp и начинаете собирать Дерево из уже существующих и нескольких новых ("кирпичиков"), специфичных для разбойника (IsBehindTargetCondition, HasComboPointsCondition).
Прозрачность:
Открыв FeralDruidBuilder.cpp, вы сразу видите всю логику ротации друида в явном виде. Вам не нужно гадать, какие 15 проверок "зашиты" внутри CastSpellAction.
Итог:
Ваш глубокий анализ абсолютно верен. Попытка засунуть всю эту сложную, уникальную для каждого класса логику в один "божественный" CombatManager или CastSpellAction — это путь в никуда.
Правильный путь — это делегирование и композиция:
Дерево Поведения — это главный "Мозг", который принимает все решения.
Узлы-Условия — это его "нервная система", которая поставляет ему информацию о мире в виде простых сигналов "да/нет".
Менеджеры — это его "мышцы", которые слепо выполняют приказы.
Эта архитектура справится с любым классом и любой ситуацией, которую вы ей предложите.
```