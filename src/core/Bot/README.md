Модуль Bot — Мозг и Исполнитель
Этот документ описывает внутреннюю архитектуру и принципы работы модуля Bot, который является ядром всей логики принятия решений в MDBot2.
1. Общая философия
Модуль Bot — это самодостаточный "организм", который:
Получает приказы от GUI в виде простой структуры настроек (BotStartSettings).
Воспринимает мир через GameObjectManager (данные из SharedMemory).
Взаимодействует с миром через MovementManager (команды в SharedMemory).
Принимает решения, используя Дерево Поведения (BehaviorTree).
Bot (Bot.h/.cpp) — это класс-оркестратор. Он владеет всеми своими "органами" (менеджерами), инжектирует DLL, создает SharedMemory и запускает основной рабочий цикл в отдельном потоке.
2. Структура и компоненты
2.1. Инструменты (Менеджеры)
Это "органы чувств и действия" бота.
GameObjectManager (GameObjectManager.h/.cpp)
Роль: Наши "глаза".
Источник данных: Читает массив объектов (SharedData::visibleObjects) из SharedMemory. Этот массив постоянно обновляется инжектированной MDBot_Client.dll.
Задача: Является кэшем видимых игровых объектов. Он создает, обновляет и удаляет C++ объекты (Player, Unit, GameObject) на основе данных из DLL. Предоставляет Дереву Поведения удобный доступ к этому кэшу (getObjectsByType, getObjectByGuid).
MovementManager (MovementManager.h/.cpp)
Роль: Наши "ноги".
Принцип работы: Отправка асинхронных команд в MDBot_Client.dll.
Механизм: Когда в Дереве Поведения вызывается moveTo(), менеджер НЕ двигает персонажа сам. Он записывает команду (ClientCommandType::MoveTo) и координаты цели в специальную секцию SharedMemory (SharedData::commandToDll). DLL внутри игры постоянно мониторит эту секцию, ловит команду и выполняет Click-to-Move, используя внутриигровые функции.
Почему так? Чтобы вся логика, зависящая от адресов и вызовов функций игры, была инкапсулирована в DLL. Это делает основной исполняемый файл чистым и независимым от конкретной версии игры.
Character (Character.h/.cpp)
Роль: Наше "самоощущение".
Источник данных: В отличие от GameObjectManager, этот класс читает данные (HP, мана, позиция, ID карты) напрямую из памяти игры через MemoryManager.
Механизм получения указателя: При создании Character устанавливает CharacterHook (0x4FA64E), который перехватывает указатель на структуру игрока и сохраняет его в специально выделенную область памяти. Character::updateFromMemory() читает этот указатель, а затем по смещениям читает все остальные данные.
Почему так? Данные о самом персонаже нужны постоянно и с максимальной точностью, независимо от цикла обновления объектов в DLL.
Низкоуровневые хуки
Менеджеры используют хуки для получения критически важной информации или для обхода защит.
CharacterHook: Используется Character для получения базового адреса структуры игрока.
TargetHook: (Пока не используется, но предназначен для GameObjectManager) Позволяет получить указатель на текущую цель игрока.
GetComputerNameHook: Хук для обхода античит-систем, подменяющий имя компьютера.
TeleportExecutor и TeleportStepFlagHook: Низкоуровневая реализация телепортации. На данный момент не интегрирована в MovementManager, но является альтернативным способом передвижения.
2.2. Логика (Дерево Поведения)
Это "мозг" бота, который использует "инструменты" для принятия решений.
Behaviors/
Библиотека "кирпичиков" LEGO. Это атомарные, переиспользуемые действия и условия.
FindGameObjectByTypeAction: Использует GameObjectManager, чтобы найти ближайший объект нужного типа.
MoveToTargetAction: Использует GameObjectManager для получения координат цели и MovementManager для отправки команды на движение.
Modules/
Классы-"архитекторы", которые строят из "кирпичиков" полноценные программы действий.
OreGrindModule: Собирает простое Дерево Поведения (SequenceNode), которое сначала ищет объект (FindGameObjectByTypeAction), а затем идет к нему (MoveToTargetAction).
3. Связь с другими частями проекта
3.1. Связь с GUI
Управление: GUI не управляет ботом напрямую. Он общается с объектом Bot через сигналы и слоты Qt.
Настройки: При нажатии кнопки "Старт" BotWidget собирает все настройки из разных вкладок в единую структуру BotStartSettings и передает ее в слот Bot::start(). Bot использует эту структуру, чтобы выбрать, какой Module использовать для построения Дерева Поведения.
Обратная связь: Bot отправляет сигналы в GUI (finished, debugDataReady), чтобы информировать о своем состоянии и предоставлять данные для отладки.
3.2. Связь с MDBot_Client.dll (через SharedMemory)
SharedMemory — это наш двунаправленный контракт с DLL.
Канал ИГРА -> БОТ:
Что: Большой блок данных SharedData::visibleObjects.
Кто пишет: MDBot_Client.dll.
Кто читает: GameObjectManager.
Канал БОТ -> ИГРА:
Что: Маленькая структура SharedData::commandToDll.
Кто пишет: MovementManager.
Кто читает: MDBot_Client.dll.
4. Жизненный цикл одного "тика"
Весь процесс работы бота можно описать как бесконечный цикл (Bot::run), который повторяется каждые 150 мс:
Сбор данных:
Bot читает весь блок SharedData.
GameObjectManager обновляет свой кэш объектов на основе прочитанных данных.
Character читает актуальные данные о персонаже напрямую из памяти.
Принятие решения:
Bot выполняет один tick() корня активного Дерева Поведения.
Дерево спускается по веткам. Например, SequenceNode в OreGrindModule запускает FindGameObjectByTypeAction.
Действие:
FindGameObjectByTypeAction обращается к GameObjectManager, находит цель и возвращает Success.
SequenceNode переходит к MoveToTargetAction.
MoveToTargetAction берет GUID цели, получает ее координаты у GameObjectManager и вызывает movementManager->moveTo().
Команда:
MovementManager записывает команду на движение в SharedMemory.
На этом "тик" со стороны MDBot2.exe завершается. В это же время DLL в игре видит команду и начинает движение персонажа.
Пауза в 150 мс, после чего цикл повторяется.