Золотые правила работы с DllMain
DllMain — это не обычная функция. Она вызывается загрузчиком Windows в очень хрупком состоянии процесса (Loader Lock). Нарушение этих правил ведет к тихим провалам или необъяснимым падениям.
НИКАКОГО C++ RUNTIME (CRT): Внутри DllMain ЗАПРЕЩЕНО использовать практически любую функциональность стандартной библиотеки C++. Это включает:
std::string, std::vector, std::map и другие контейнеры (они могут выделять память).
std::thread, std::chrono (они зависят от CRT).
Потоки ввода/вывода (iostream, fstream).
Причина: C++ Runtime еще не инициализирован. Попытка его использовать — это как включить электроприбор в доме, куда еще не подвели электричество.
НИКАКИХ СЛОЖНЫХ WINAPI ФУНКЦИЙ: Нельзя вызывать функции, которые могут сами загружать другие DLL или выполнять сложную синхронизацию. MessageBox — плохой пример, CreateFile — тоже.
Причина: Это может привести к взаимной блокировке (deadlock), когда твоя DLL ждет систему, а система ждет, пока твоя DllMain завершится.
ДЕЛАЙ БЫСТРО: Код в DllMain должен выполняться мгновенно. Он блокирует работу всего процесса, пока не завершится.
ГЛАВНЫЙ ВЫВОД: Единственная задача DllMain — это выполнить простейшую инициализацию на чистом WinAPI. Идеальный сценарий — создать новый поток (CreateThread) для всей остальной работы и немедленно выйти.

## Уроки, извлеченные из отладки DLL

1.  **Проблема зависимостей:** Если DLL зависит от других DLL (например, `capstone.dll`), эти зависимости должны быть доступны процессу игры. Самый простой способ — положить их рядом с `.exe` игры. Самый правильный — **статически слинковать** все зависимости, чтобы DLL стала самодостаточной.

2.  **Глобальные объекты C++:** **ЗАПРЕЩЕНО** создавать глобальные экземпляры классов C++ (`MyClass g_myObject;`). Их конструкторы вызываются до `DllMain` и до инициализации C++ Runtime, что приводит к тихому провалу загрузки DLL.
    *   **Решение:** Использовать **отложенную инициализацию**. Создавать глобальный **указатель** (`MyClass* g_myObject = nullptr;`), а сам объект создавать через `new` внутри потока, запущенного из `DllMain`.

3.  **Соглашения о вызовах и `__asm` — Убийцы №1 и №2:** При перехвате функции нельзя просто вызвать свою C++ логику. Это **разрушает стек** и ведет к крашу. Пытаться исправить это с помощью `__declspec(naked)` и `__asm` в современном C++ — путь к несовместимости с компилятором и ошибкам сборки.
    *   **Решение:** **Динамическая генерация кода (Shellcoding).** Вместо того чтобы просить компилятор создать ассемблерный код, мы **генерируем его сами**, байт за байтом, во время выполнения (`VirtualAlloc` + `memcpy`). Этот "ручной" обработчик сохраняет состояние (`pushad`), вызывает C++ "мост", восстанавливает состояние (`popad`) и безопасно передает управление дальше через `JMP`. Это не зависит от компилятора и работает всегда.
4.  **Логика обработчика хука: Не нарушай поток управления!** Ассемблерный "мост" и C++ обработчик — это команда, где у каждого своя роль. Нарушение этой логики приводит к повреждению стека и крашу.
    *   **Проблема:** В C++ обработчике (`handler`) был сделан прямой вызов трамплина (`((void (*)())m_trampoline)();`). Этот вызов компилируется в инструкцию `CALL`, которая кладет на стек адрес возврата. Однако трамплин завершается инструкцией `JMP`, а не `RET`, поэтому управление в C++ функцию никогда не возвращается. В результате стек остается испорченным, что приводит к крашу при следующей операции со стеком (например, `push`).
    *   **Решение:** Ассемблерный "мост" (`m_handlerStub`) уже спроектирован так, чтобы **самостоятельно** вызвать трамплин **после** того, как C++ функция `handler` завершится и вернет ему управление.
    *   **Золотое правило:** Задача C++ обработчика — **только выполнить полезную нагрузку** и завершиться (`return`). Он не должен управлять потоком выполнения хука или вызывать трамплин. За это отвечает ассемблерная обертка.